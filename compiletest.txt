F00:0001       ; 1 seul buffer, grand buffer plein de sample, OK
F00:0002       ; tester avec 2 grands buffers pré-remplis et changement de buffer : inutile
F00:0003       
F00:0004       
F00:0005       
F00:0006       
F00:0007       ; OK :faire un dma de la taille du sample : 75851 => 83200
F00:0008       ; OK :copier le sample dans le dma
F00:0009       ; OK :jouer le dma à 8000HZ : us = 125
F00:0010       ; copier le sample chaque vbl : 160 octets
F00:0011       ; jouer le sample à 20833 hz
F00:0012       ; copier le sample chaque vbl : 416 octets
F00:0013       
F00:0014       	.org 0x8000
F00:0015       
F00:0016       .include "swis.h.asm"
F01:0001       .equ OS_WriteC, 0
F01:0002       .equ OS_WriteO, 2
F01:0003       .equ OS_NewLine, 3
F01:0004       .equ OS_Byte, 6
F01:0005       .equ XOS_Byte, OS_Byte | (1 << 17)
F01:0006       .equ OS_Word, 7
F01:0007       .equ OS_File, 8
F01:0008       .equ OS_Exit, 0x11
F01:0009       .equ OS_BreakPt, 0x17
F01:0010       .equ OS_ChangeDynamicArea, 0x2a
F01:0011       .equ OS_GenerateError, 0x2b
F01:0012       .equ OS_ReadVduVariables, 0x31
F01:0013       .equ OS_ReadMonotonicTime, 0x42
F01:0014       .equ OS_ReadDynamicArea, 0x5c
F01:0015       .equ OS_ConvertCardinal4, 0xd8	
F01:0016       .equ OS_EnterOS, 0x16						; supervisor
F01:0017       .equ OS_supervisor, 0x16						; supervisor
F01:0018       
F01:0019       
F01:0020       .equ OS_Module, 0x1E
F01:0021       
F01:0022       .equ OSByte_EventEnable, 14
F01:0023       .equ OSByte_EventDisable, 13
F01:0024       .equ OSByte_Vsync, 19
F01:0025       .equ OSByte_WriteVDUBank, 112
F01:0026       .equ OSByte_WriteDisplayBank, 113
F01:0027       .equ OSByte_ReadKey, 129
F01:0028       
F01:0029       .equ OSWord_WritePalette, 12
F01:0030       
F01:0031       .equ IKey_LeftClick, 0xf6
F01:0032       .equ IKey_RightClick, 0xf4
F01:0033       .equ IKey_Space, 0x9d
F01:0034       
F01:0035       .equ DynArea_Screen, 2
F01:0036       
F01:0037       .equ VD_ScreenStart, 148 
F01:0038       
F01:0039       .equ OS_Claim, 0x1f
F01:0040       .equ OS_Release, 0x20
F01:0041       .equ OS_AddToVector, 0x47
F01:0042       
F01:0043       .equ ErrorV, 0x01
F01:0044       .equ EventV, 0x10
F01:0045       .equ Event_VSync, 4
F01:0046       
F01:0047       .equ OS_ConvertHex2, 0xd1
F01:0048       .equ OS_ConvertHex4, 0xd2
F01:0049       .equ OS_ConvertHex8, 0xd4
F01:0050       
F01:0051       .equ QTM_Load, 0x47E40
F01:0052       .equ QTM_Start, 0x47E41
F01:0053       .equ QTM_Stop, 0x47E42
F01:0054       .equ QTM_SetSampleSpeed, 0x47E49
F01:0055       
F01:0056       ; Rasterman 
F01:0057       .equ	RasterMan_Version,			0x47e84
F01:0058       .equ	RasterMan_SetTables,		0x47e83
F01:0059       .equ	RasterMan_Install,			0x47e80
F01:0060       .equ	RasterMan_Release,			0x47e81
F01:0061       .equ	RasterMan_Wait,				0x47e82
F01:0062       .equ	RasterMan_ReadScanline,		0x47e85
F01:0063       .equ	RasterMan_SetVIDCRegister,	0x47e86
F01:0064       .equ	RasterMan_SetMEMCRegister,	0x47e87
F01:0065       .equ	RasterMan_QTMParamAddr,		0x47e88
F01:0066       .equ	RasterMan_ScanKeyboard,		0x47e89
F01:0067       .equ	RasterMan_ClearKeyBuffer, 	0x47e8a
F01:0068       .equ	RasterMan_ReadScanAddr,		0x47e8b
F01:0069       
F01:0070       ; QDebug_Break
F01:0071       .equ	BKP, 0x44B85
F01:0072       
F01:0073       ; XOS
F01:0074       .equ	XOS_ServiceCall,		0x20030
F01:0075       .equ	OS_ReadMonotonicTime,		0x42
F01:0076       
F01:0077       ; memory management
F01:0078       .equ	OS_ReadMemMapInfo,		0x51
F01:0079       .equ	OS_FindMemMapEntries,		0x60
F01:0080       .equ	XSound_SoundLog,		0x60181
F01:0081       .equ	XSound_Volume,			0x60180
F01:0082       .equ	XSound_Configure,		0x60140
F01:0083       .equ	XSound_Enable,			0x60141
F01:0084       .equ	Sound_Stereo,			0x40142
F01:0085       .equ	XSound_Stereo,			0x60142
F01:0086       
F00:0017       
F00:0018       .equ		taille_dma,					83200
F00:0019       .equ		longueur_du_sample,				75851
F00:0020       .equ		ms_freq_Archi,					32				; 125=8000hz 32=31250
F00:0021       ;.equ		nb_octets_par_vbl,				416
F00:0022       
F00:0023       
F00:0024       
F00:0025       	; read memc control register
F00:0026       	mov		R0,#0
               S01:00008000:  00 00 A0 E3
F00:0027       	mov		R1,#0
               S01:00008004:  00 10 A0 E3
F00:0028       	swi		0x1A
               S01:00008008:  1A 00 00 EF
F00:0029       	str		R0,memc_control_register_original
               S01:0000800C:  98 06 8F E5
F00:0030       
F00:0031       ; set sound volume
F00:0032       	mov		R0,#127							; maxi 127
               S01:00008010:  7F 00 A0 E3
F00:0033       	SWI		XSound_Volume	
               S01:00008014:  80 01 06 EF
F00:0034       
F00:0035       ; read sound volume
F00:0036       	mov		R0,#0							; 0=read = OK 127
               S01:00008018:  00 00 A0 E3
F00:0037       	SWI		XSound_Volume	
               S01:0000801C:  80 01 06 EF
F00:0038       	
F00:0039       	bl		create_table_lin2log_edz
               S01:00008020:  B3 00 00 EB
F00:0040       	
F00:0041       	bl		conversion_du_sample_en_mu_law 
               S01:00008024:  85 00 00 EB
F00:0042       
F00:0043       
F00:0044       
F00:0045        ; Set screen size for number of buffers
F00:0046       	MOV 	r0, #DynArea_Screen
               S01:00008028:  02 00 A0 E3
F00:0047       	SWI 	OS_ReadDynamicArea
               S01:0000802C:  5C 00 00 EF
F00:0048       	; r1=taille actuelle de la memoire ecran
F00:0049       	str		R1,taille_actuelle_memoire_ecran
               S01:00008030:  78 16 8F E5
F00:0050       	MOV r0, #DynArea_Screen
               S01:00008034:  02 00 A0 E3
F00:0051       ; 416 * ( 32+258+32+258+32)
F00:0052       	mov		R1,#taille_dma
               S01:00008038:  45 1C A0 E3 01 18 81 E3
F00:0053       	add		R1,R1,#taille_dma
               S01:00008040:  45 1C 81 E2 01 18 81 E2
F00:0054       	add		R1,R1,#65536
               S01:00008048:  01 18 81 E2
F00:0055       	SWI		OS_ChangeDynamicArea
               S01:0000804C:  2A 00 00 EF
F00:0056       	
F00:0057       ; taille dynamic area screen = 320*256*2
F00:0058       
F00:0059       	MOV		r0, #DynArea_Screen
               S01:00008050:  02 00 A0 E3
F00:0060       	SWI		OS_ReadDynamicArea
               S01:00008054:  5C 00 00 EF
F00:0061       	
F00:0062       	; r0 = pointeur memoire ecrans
F00:0063       	ldr		R10,taille_actuelle_memoire_ecran
               S01:00008058:  50 A6 9F E5
F00:0064       	add		R0,R0,R10		; au bout de la mémoire video, le buffer dma
               S01:0000805C:  0A 00 80 E0
F00:0065       	add		R0,R0,#65536
               S01:00008060:  01 08 80 E2
F00:0066       	str		R0,adresse_dma1_logical
               S01:00008064:  48 06 8F E5
F00:0067       	add		R1,R0,#taille_dma
               S01:00008068:  45 1C 80 E2 01 18 81 E2
F00:0068       	str		R1,adresse_dma1_logical_fin
               S01:00008070:  40 16 8F E5
F00:0069       	str		R1,adresse_dma2_logical
               S01:00008074:  44 16 8F E5
F00:0070       	add		R1,R0,#taille_dma
               S01:00008078:  45 1C 80 E2 01 18 81 E2
F00:0071       	str		R1,adresse_dma2_logical_fin
               S01:00008080:  3C 16 8F E5
F00:0072       	
F00:0073       	
F00:0074       	
F00:0075       
F00:0076       	
F00:0077       	
F00:0078       	
F00:0079       		ldr		R6,adresse_dma1_logical
               S01:00008084:  28 66 9F E5
F00:0080       		ldr		R5,adresse_dma2_logical
               S01:00008088:  30 56 9F E5
F00:0081       	
F00:0082       		SWI       OS_ReadMemMapInfo 		;  read the page size used by the memory controller and the number of pages in use
               S01:0000808C:  51 00 00 EF
F00:0083       		STR       R0,pagesize
               S01:00008090:  54 06 8F E5
F00:0084       		STR       R1,numpages
               S01:00008094:  54 16 8F E5
F00:0085       
F00:0086       		SUB       R4,R0,#1			; R4 = pagesize - 1
               S01:00008098:  01 40 40 E2
F00:0087       		BIC       R7,R5,R4          ; page for dmabuffer2 : 
               S01:0000809C:  04 70 C5 E1
F00:0088       		BIC       R8,R6,R4          ; page for dmabuffer1 : and R6 & not(R4)
               S01:000080A0:  04 80 C6 E1
F00:0089       
F00:0090       		SUB       R5,R5,R7          ;offset into page dma2
               S01:000080A4:  07 50 45 E0
F00:0091       		SUB       R6,R6,R8          ;offset into page dma1
               S01:000080A8:  08 60 46 E0
F00:0092       		ADR       R0,pagefindblk
               S01:000080AC:  06 0C 8F E2 1C 00 80 E2
F00:0093       		
F00:0094       		MOV       R1,#0
               S01:000080B4:  00 10 A0 E3
F00:0095       		STR       R1,[R0,#0]
               S01:000080B8:  00 10 80 E5
F00:0096       		STR       R1,[R0,#8]
               S01:000080BC:  08 10 80 E5
F00:0097       		MVN       R1,#0
               S01:000080C0:  00 10 E0 E3
F00:0098       		STR       R1,[R0,#12]
               S01:000080C4:  0C 10 80 E5
F00:0099       		STR       R7,[R0,#4]
               S01:000080C8:  04 70 80 E5
F00:0100       		SWI       OS_FindMemMapEntries 		;not RISC OS 2 or earlier
               S01:000080CC:  60 00 00 EF
F00:0101       		LDR       R1,[R0,#0]
               S01:000080D0:  00 10 90 E5
F00:0102       		LDR       R4,pagesize
               S01:000080D4:  10 46 9F E5
F00:0103       		MUL       R1,R4,R1
               S01:000080D8:  94 01 01 E0
F00:0104       		ADD       R1,R1,R5
               S01:000080DC:  05 10 81 E0
F00:0105       		STR       R1,adresse_dma2_memc 			;got the correct phys addr of buf2 (R7)
               S01:000080E0:  E0 15 8F E5
F00:0106       		str			R1,adresse_dma2_memc_courant
               S01:000080E4:  E0 15 8F E5
F00:0107       	
F00:0108       
F00:0109       		MOV       R1,#0
               S01:000080E8:  00 10 A0 E3
F00:0110       		STR       R1,[R0,#0]
               S01:000080EC:  00 10 80 E5
F00:0111       		STR       R1,[R0,#8]
               S01:000080F0:  08 10 80 E5
F00:0112       		MVN       R1,#0
               S01:000080F4:  00 10 E0 E3
F00:0113       		STR       R1,[R0,#12]
               S01:000080F8:  0C 10 80 E5
F00:0114       		STR       R8,[R0,#4]
               S01:000080FC:  04 80 80 E5
F00:0115       		SWI       OS_FindMemMapEntries ;not RISC OS 2 or earlier
               S01:00008100:  60 00 00 EF
F00:0116       		LDR       R1,[R0,#0]
               S01:00008104:  00 10 90 E5
F00:0117       		LDR       R4,pagesize
               S01:00008108:  DC 45 9F E5
F00:0118       		MUL       R1,R4,R1
               S01:0000810C:  94 01 01 E0
F00:0119       		ADD       R1,R1,R6
               S01:00008110:  06 10 81 E0
F00:0120       		STR       R1,adresse_dma1_memc ;got the correct phys addr of buf1 (R8)
               S01:00008114:  A0 15 8F E5
F00:0121       		
F00:0122       
F00:0123       ; 00 = silence
F00:0124       ; 02 = tres faible
F00:0125       ; 01 = beaucoup plus fort
F00:0126       ; 120 > 01
F00:0127       
F00:0128       
F00:0129       
F00:0130       
F00:0131       		; on met à zéro les buffers DMA
F00:0132       	ldr		R1,adresse_dma1_logical
               S01:00008118:  94 15 9F E5
F00:0133       	mov		R2,#taille_dma/4
               S01:0000811C:  51 2C A0 E3 40 20 82 E3
F00:0134       	ldr		R0,valeurson
               S01:00008124:  0C 00 9F E5
F00:0135       boucle_cls_buffer_dma:
F00:0136       	str		R0,[R1],#4
               S01:00008128:  04 00 81 E4
F00:0137       	subs	R2,R2,#1
               S01:0000812C:  01 20 52 E2
F00:0138       	bgt		boucle_cls_buffer_dma
               S01:00008130:  FC FF FF CA
F00:0139       
F00:0140       	
F00:0141       	b		continue
               S01:00008134:  00 00 00 EA
F00:0142       
F00:0143       valeurson:		.long		0x00000000
               S01:00008138:  00 00 00 00
F00:0144       
F00:0145       continue:
F00:0146       	bl		copie_sample_dans_buffer_dma_en_entier
               S01:0000813C:  4C 00 00 EB
F00:0147       
F00:0148       
F00:0149       ; system son Risc OS
F00:0150       
F00:0151       
F00:0152       	MOV       R0,#0							;  	Channels for 8 bit sound
               S01:00008140:  00 00 A0 E3
F00:0153       	MOV       R1,#0						; Samples per channel (in bytes)
               S01:00008144:  00 10 A0 E3
F00:0154       	MOV       R2,#0						; Sample period (in microseconds per channel) 
               S01:00008148:  00 20 A0 E3
F00:0155       	MOV       R3,#0
               S01:0000814C:  00 30 A0 E3
F00:0156       	MOV       R4,#0
               S01:00008150:  00 40 A0 E3
F00:0157       	SWI       XSound_Configure						;"Sound_Configure"
               S01:00008154:  40 01 06 EF
F00:0158       	
F00:0159       	adr		R5,backup_params_sons
               S01:00008158:  05 5C 8F E2 94 50 85 E2
F00:0160       	stmia	R5,{r0-R4}
               S01:00008160:  1F 00 85 E8
F00:0161       
F00:0162       
F00:0163       
F00:0164       	MOV       R0,#1							;  	Channels for 8 bit sound
               S01:00008164:  01 00 A0 E3
F00:0165       	MOV       R1,#taille_dma		; Samples per channel (in bytes)
               S01:00008168:  45 1C A0 E3 01 18 81 E3
F00:0166       	MOV       R2,#ms_freq_Archi				; Sample period (in microseconds per channel)  = 48  / 125 pour 8000hz
               S01:00008170:  20 20 A0 E3
F00:0167       	MOV       R3,#0
               S01:00008174:  00 30 A0 E3
F00:0168       	MOV       R4,#0
               S01:00008178:  00 40 A0 E3
F00:0169       	SWI       XSound_Configure						;"Sound_Configure"
               S01:0000817C:  40 01 06 EF
F00:0170       
F00:0171       
F00:0172       	SWI		OS_EnterOS						; OS_supervisor
               S01:00008180:  16 00 00 EF
F00:0173       	MOVNV R0,R0 
               S01:00008184:  00 00 A0 F1
F00:0174       
F00:0175       ; installation vsync RM
F00:0176       	bl		install_vsync
               S01:00008188:  7F 00 00 EB
F00:0177       	
F00:0178       	teqp  r15,#0                     
               S01:0000818C:  00 F0 3F E3
F00:0179       	mov   r0,r0		
               S01:00008190:  00 00 A0 E1
F00:0180       
F00:0181       
F00:0182       ; write memc control register, start sound
F00:0183       	SWI		OS_EnterOS
               S01:00008194:  16 00 00 EF
F00:0184       	MOVNV R0,R0
               S01:00008198:  00 00 A0 F1
F00:0185       	ldr		R0,memc_control_register_original	
               S01:0000819C:  08 05 9F E5
F00:0186       	orr		R0,R0,#0b100000000000
               S01:000081A0:  02 0B 80 E3
F00:0187       	str		R0,[R0]
               S01:000081A4:  00 00 80 E5
F00:0188       	
F00:0189       ; change bien la frequence
F00:0190       ;sound frequency register ? 0xC0 / VIDC
F00:0191       	mov		R0,#ms_freq_Archi-1
               S01:000081A8:  1F 00 A0 E3
F00:0192       
F00:0193       	mov		r1,#0x3400000               
               S01:000081AC:  0D 15 A0 E3
F00:0194       ; sound frequency VIDC
F00:0195       	mov		R2,#0xC0000100
               S01:000081B0:  01 2C A0 E3 03 21 82 E3
F00:0196       	orr   r0,r0,R2
               S01:000081B8:  02 00 80 E1
F00:0197       	str   r0,[r1]  
               S01:000081BC:  00 00 81 E5
F00:0198       	
F00:0199       	teqp  r15,#0                     
               S01:000081C0:  00 F0 3F E3
F00:0200       	mov   r0,r0	
               S01:000081C4:  00 00 A0 E1
F00:0201       
F00:0202       	SWI		OS_EnterOS
               S01:000081C8:  16 00 00 EF
F00:0203       	MOVNV R0,R0
               S01:000081CC:  00 00 A0 F1
F00:0204       	bl		set_dma_dma1
               S01:000081D0:  38 00 00 EB
F00:0205       	teqp  r15,#0                     
               S01:000081D4:  00 F0 3F E3
F00:0206       	mov   r0,r0
               S01:000081D8:  00 00 A0 E1
F00:0207       	
F00:0208       boucle:
F00:0209       
F00:0210       ; vsync par risc os
F00:0211       ;	mov		R0,#0x13
F00:0212       ;	swi		0x6
F00:0213       
F00:0214       	bl		wait_VBL
               S01:000081DC:  9E 00 00 EB
F00:0215       
F00:0216       
F00:0217       	SWI		OS_EnterOS
               S01:000081E0:  16 00 00 EF
F00:0218       	MOVNV R0,R0
               S01:000081E4:  00 00 A0 F1
F00:0219       	bl		set_dma_dma1
               S01:000081E8:  32 00 00 EB
F00:0220       	teqp  r15,#0                     
               S01:000081EC:  00 F0 3F E3
F00:0221       	mov   r0,r0
               S01:000081F0:  00 00 A0 E1
F00:0222       
F00:0223       	bl      scankeyboard
               S01:000081F4:  9D 00 00 EB
F00:0224       
F00:0225       test_touche_space:
F00:0226       	cmp		R0,#0x5F
               S01:000081F8:  5F 00 50 E3
F00:0227       	bne		boucle
               S01:000081FC:  F6 FF FF 1A
F00:0228       
F00:0229       exit:
F00:0230       	nop
               S01:00008200:  00 00 A0 E1
F00:0231       	nop
               S01:00008204:  00 00 A0 E1
F00:0232       
F00:0233       	bl		wait_VBL
               S01:00008208:  93 00 00 EB
F00:0234       ;-----------------------
F00:0235       ;sortie
F00:0236       ;-----------------------
F00:0237       
F00:0238       	bl	remove_VBL
               S01:0000820C:  4B 00 00 EB
F00:0239       
F00:0240       
F00:0241       	
F00:0242       	adr		R5,backup_params_sons
               S01:00008210:  01 5B 8F E2 DC 50 85 E2
F00:0243       	ldmia	R5,{r0-R4}
               S01:00008218:  1F 00 95 E8
F00:0244       
F00:0245       	SWI       XSound_Configure						;"Sound_Configure"
               S01:0000821C:  40 01 06 EF
F00:0246       	
F00:0247       	mov		R0,#01								; Disable sound output 
               S01:00008220:  01 00 A0 E3
F00:0248       	SWI		XSound_Enable								; Sound_Enable
               S01:00008224:  41 01 06 EF
F00:0249       
F00:0250       
F00:0251       	MOV r0,#22	;Set MODE
               S01:00008228:  16 00 A0 E3
F00:0252       	SWI OS_WriteC
               S01:0000822C:  00 00 00 EF
F00:0253       	MOV r0,#12
               S01:00008230:  0C 00 A0 E3
F00:0254       	SWI OS_WriteC
               S01:00008234:  00 00 00 EF
F00:0255       	
F00:0256       	
F00:0257       ; sortie
F00:0258       	MOV R0,#0
               S01:00008238:  00 00 A0 E3
F00:0259       	SWI OS_Exit
               S01:0000823C:  11 00 00 EF
F00:0260       
F00:0261       
F00:0262       ; ----------------- Routines ------------------
F00:0263       
F00:0264       conversion_du_sample_en_mu_law:
F00:0265       		ldr		R1,pointeur_sample
               S01:00008240:  C4 14 9F E5
F00:0266       		mov		R11,#longueur_du_sample
               S01:00008244:  4A BB A0 E3 4B B0 8B E3
F00:0267       		adr		R6,lin2logtab
               S01:0000824C:  01 6B 8F E2 C0 60 86 E2
F00:0268       		
F00:0269       boucle_convert_sample_mu_law:
F00:0270       
F00:0271       	ldrb	R0,[R1]
               S01:00008254:  00 00 D1 E5
F00:0272       	add		R0,R0,#1
               S01:00008258:  01 00 80 E2
F00:0273       	and		R0,R0,#0b11111110
               S01:0000825C:  FE 00 00 E2
F00:0274       	ldrb	R0,[R6,R0]
               S01:00008260:  00 00 D6 E7
F00:0275       	strb	R0,[R1],#1
               S01:00008264:  01 00 C1 E4
F00:0276       	subs	R11,R11,#1
               S01:00008268:  01 B0 5B E2
F00:0277       	bgt		boucle_convert_sample_mu_law
               S01:0000826C:  F8 FF FF CA
F00:0278       ; - fin de conversion des samples en mu-law
F00:0279       	mov		pc,lr
               S01:00008270:  0E F0 A0 E1
F00:0280       
F00:0281       copie_sample_dans_buffer_dma_en_entier:
F00:0282       
F00:0283       		ldr		R1,pointeur_sample
               S01:00008274:  90 14 9F E5
F00:0284       		ldr		R2,adresse_dma1_logical
               S01:00008278:  34 24 9F E5
F00:0285       		ldr		R3,adresse_dma2_logical
               S01:0000827C:  3C 34 9F E5
F00:0286       
F00:0287       		mov		R11,#longueur_du_sample/4
               S01:00008280:  4A BC A0 E3 12 B0 8B E3
F00:0288       		
F00:0289       boucle_copie_sample_en_entier:
F00:0290       		ldrb	R0,[R1],#1
               S01:00008288:  01 00 D1 E4
F00:0291       		strb	R0,[R2],#1
               S01:0000828C:  01 00 C2 E4
F00:0292       		strb	R0,[R3],#1
               S01:00008290:  01 00 C3 E4
F00:0293       		strb	R0,[R2],#1
               S01:00008294:  01 00 C2 E4
F00:0294       		strb	R0,[R3],#1
               S01:00008298:  01 00 C3 E4
F00:0295       	strb	R0,[R2],#1
               S01:0000829C:  01 00 C2 E4
F00:0296       		strb	R0,[R3],#1
               S01:000082A0:  01 00 C3 E4
F00:0297       	strb	R0,[R2],#1
               S01:000082A4:  01 00 C2 E4
F00:0298       		strb	R0,[R3],#1
               S01:000082A8:  01 00 C3 E4
F00:0299       
F00:0300       		subs	R11,R11,#1
               S01:000082AC:  01 B0 5B E2
F00:0301       		bgt		boucle_copie_sample_en_entier
               S01:000082B0:  F4 FF FF CA
F00:0302       
F00:0303       		mov		pc,lr
               S01:000082B4:  0E F0 A0 E1
F00:0304       
F00:0305       set_dma_dma1:
F00:0306       	ldr		  R12,adresse_dma2_memc
               S01:000082B8:  08 C4 9F E5
F00:0307       	mov       R10,#taille_dma
               S01:000082BC:  45 AC A0 E3 01 A8 8A E3
F00:0308       	ADD       R10,R10,R12         ;SendN
               S01:000082C4:  0C A0 8A E0
F00:0309       	SUB       R10,R10,#16         ; fixit ;-)
               S01:000082C8:  10 A0 4A E2
F00:0310       
F00:0311       	MOV       R12,R12,LSR#2       ;(Sstart/16) << 2
               S01:000082CC:  2C C1 A0 E1
F00:0312       	MOV       R10,R10,LSR#2       ;(SendN/16) << 2
               S01:000082D0:  2A A1 A0 E1
F00:0313       	MOV          R0,#0x3600000     ;memc base
               S01:000082D4:  36 06 A0 E3
F00:0314       	ADD       R1,R0,#0x0080000     ;Sstart
               S01:000082D8:  02 17 80 E2
F00:0315       	ADD       R2,R0,#0x00A0000     ;SendN
               S01:000082DC:  0A 28 80 E2
F00:0316       	ORR       R1,R1,R12           ;Sstart
               S01:000082E0:  0C 10 81 E1
F00:0317       	ORR       R2,R2,R10           ;SendN
               S01:000082E4:  0A 20 82 E1
F00:0318       	STR       R2,[R2]
               S01:000082E8:  00 20 82 E5
F00:0319       	STR       R1,[R1]
               S01:000082EC:  00 10 81 E5
F00:0320       
F00:0321       	mov		pc,lr
               S01:000082F0:  0E F0 A0 E1
F00:0322       
F00:0323       create_table_lin2log_edz:
F00:0324       	adr		R11,lin2logtab
               S01:000082F4:  01 BB 8F E2 18 B0 8B E2
F00:0325       	mov		R1,#0
               S01:000082FC:  00 10 A0 E3
F00:0326       	mov		R2,#256
               S01:00008300:  01 2C A0 E3
F00:0327       
F00:0328       boucle_table_lin2log_edz:
F00:0329       	mov		R0,R1,LSL #24			; de signed 8 bits à signed 32 bits
               S01:00008304:  01 0C A0 E1
F00:0330       	SWI     XSound_SoundLog		; This SWI is used to convert a signed linear sample to the 8 bit logarithmic format that’s 
               S01:00008308:  81 01 06 EF
F00:0331       ; résultat dans R0
F00:0332       	STRB    R0,[R11],#1
               S01:0000830C:  01 00 CB E4
F00:0333       	adds	R1,R1,#1
               S01:00008310:  01 10 91 E2
F00:0334       	cmp		R1,R2
               S01:00008314:  02 00 51 E1
F00:0335       	blt		boucle_table_lin2log_edz
               S01:00008318:  F9 FF FF BA
F00:0336       	mov		pc,lr
               S01:0000831C:  0E F0 A0 E1
F00:0337       	
F00:0338       	
F00:0339       
F00:0340       create_table_lin2log:
F00:0341       
F00:0342        	adr 	R11,lin2logtab
               S01:00008320:  FB BF 8F E2
F00:0343        	MOV     R1,#255
               S01:00008324:  FF 10 A0 E3
F00:0344       setlinlogtab:
F00:0345       
F00:0346       	MOV     R0,R1,LSL #24		; R0=R1<<24 : en entrée du 8 bits donc shifté en haut, sur du 32 bits
               S01:00008328:  01 0C A0 E1
F00:0347       	SWI     XSound_SoundLog		; This SWI is used to convert a signed linear sample to the 8 bit logarithmic format that’s 
               S01:0000832C:  81 01 06 EF
F00:0348       	STRB    R0,[R11,R1]			; 8 bit mu-law logarithmic sample 
               S01:00008330:  01 00 CB E7
F00:0349       	SUBS    R1,R1,#1
               S01:00008334:  01 10 51 E2
F00:0350       	BGE     setlinlogtab
               S01:00008338:  FA FF FF AA
F00:0351       	mov		pc,lr
               S01:0000833C:  0E F0 A0 E1
F00:0352       
F00:0353       remove_VBL:
F00:0354       	str		lr,save_lr
               S01:00008340:  90 E1 8F E5
F00:0355       
F00:0356       ; we own FIQs
F00:0357       				  
F00:0358       	TEQP      PC,#0x0C000001					; %11<<26 OR %01            ;disable IRQs and FIQs, switch FIQ mode
               S01:00008344:  43 F3 3F E3
F00:0359       	MOV       R0,R0
               S01:00008348:  00 00 A0 E1
F00:0360       
F00:0361       	MOV       R0,#0
               S01:0000834C:  00 00 A0 E3
F00:0362       	LDR       R1,oldIRQbranch
               S01:00008350:  1C 12 9F E5
F00:0363       	STR       R1,[R0,#0x18]        ;restore original IRQ controller
               S01:00008354:  18 10 80 E5
F00:0364       	
F00:0365       	MOV       R0,#0
               S01:00008358:  00 00 A0 E3
F00:0366       	MOV       R1,#0x3200000
               S01:0000835C:  32 16 A0 E3
F00:0367       	STRB      R0,[R1,#0x38+2]      ;set FIQ mask to 0 (disable FIQs)
               S01:00008360:  3A 00 C1 E5
F00:0368       
F00:0369       	LDR       R0,oldIRQa
               S01:00008364:  FC 01 9F E5
F00:0370       	STRB      R0,[R1,#0x18+2]
               S01:00008368:  1A 00 C1 E5
F00:0371       	LDR       R0,oldIRQb
               S01:0000836C:  F8 01 9F E5
F00:0372       	STRB      R0,[R1,#0x28+2]      ;restore IRQ masks
               S01:00008370:  2A 00 C1 E5
F00:0373       
F00:0374       	TEQP      PC,#0b11  			; (%00<<26) OR %11          ;enable IRQs and FIQs, stay SVC mode
               S01:00008374:  03 F0 3F E3
F00:0375       	MOV       R0,R0
               S01:00008378:  00 00 A0 E1
F00:0376       
F00:0377       
F00:0378       	MOV       R0,#0x0B             ;release FIQ
               S01:0000837C:  0B 00 A0 E3
F00:0379       	SWI       XOS_ServiceCall
               S01:00008380:  30 00 02 EF
F00:0380       
F00:0381       	ldr		lr,save_lr
               S01:00008384:  4C E1 9F E5
F00:0382       	mov		pc,lr					; return USER mode, leave IRQs and FIQs on
               S01:00008388:  0E F0 A0 E1
F00:0383       
F00:0384       
F00:0385       
F00:0386       install_vsync:
F00:0387       	str		lr,save_lr
               S01:0000838C:  44 E1 8F E5
F00:0388       	; appel XOS car si appel OS_SWI si erreur, ça sort directement
F00:0389       	MOV		R0,#0x0C           ;claim FIQ
               S01:00008390:  0C 00 A0 E3
F00:0390       	SWI		XOS_ServiceCall
               S01:00008394:  30 00 02 EF
F00:0391       	bvs		exit
               S01:00008398:  98 FF FF 6A
F00:0392       	
F00:0393       	TEQP	PC,#0xC000001					; bit 27 & 26 = 1, bit 0=1 : IRQ Disable+FIRQ Disable+FIRQ mode ( pour récupérer et sauvegarde
               S01:0000839C:  43 F3 3F E3
F00:0394       	
F00:0395       	MOV		R0,R0
               S01:000083A0:  00 00 A0 E1
F00:0396       
F00:0397       	ADR       R0,fiqoriginal				; sauvegarde de R8-R14
               S01:000083A4:  1A 0E 8F E2
F00:0398       	STMIA     R0,{R8-R14}
               S01:000083A8:  00 7F 80 E8
F00:0399       	
F00:0400       	MOV       R1,#0x3200000
               S01:000083AC:  32 16 A0 E3
F00:0401       	LDRB      R0,[R1,#0x18]					; lecture et sauvegarde mask IRQ A
               S01:000083B0:  18 00 D1 E5
F00:0402       	STR       R0,oldIRQa
               S01:000083B4:  AC 01 8F E5
F00:0403       	LDRB      R0,[R1,#0x28]					; lecture et sauvegarde mask IRQ B
               S01:000083B8:  28 00 D1 E5
F00:0404       	STR       R0,oldIRQb
               S01:000083BC:  A8 01 8F E5
F00:0405       	
F00:0406       	
F00:0407       ; When installing, we will start on the next VSync, so set IRQ for VSync only
F00:0408       ; and set T1 to contain 'vsyncvalue', so everything in place for VSync int...
F00:0409       
F00:0410       	MOV       R0,#0b00001000
               S01:000083C0:  08 00 A0 E3
F00:0411       	STRB      R0,[R1,#0x18+2]    ;set IRQA mask to %00001000 = VSync only : bit 3 sur mask IRQ A = vsync
               S01:000083C4:  1A 00 C1 E5
F00:0412       	MOV       R0,#0
               S01:000083C8:  00 00 A0 E3
F00:0413       	STRB      R0,[R1,#0x28+2]    ;set IRQB mask to 0					:	IRQ B mask à 0 = disabled
               S01:000083CC:  2A 00 C1 E5
F00:0414       	STRB      R0,[R1,#0x38+2]    ;set FIQ mask to 0 (disable FIQs)		:	FIRQ  mask à 0 = disabled
               S01:000083D0:  3A 00 C1 E5
F00:0415       
F00:0416       ; Timer 1 / IRQ A
F00:0417       	MOV       R0,#0xFF           ;*v0.14* set max T1 - ensure T1 doesn't trigger before first VSync!
               S01:000083D4:  FF 00 A0 E3
F00:0418       	STRB      R0,[R1,#0x50+2]    ;T1 low byte, +2 for write			: verrou / compteur = 0xFFFF
               S01:000083D8:  52 00 C1 E5
F00:0419       	STRB      R0,[R1,#0x54+2]    ;T1 high byte, +2 for write
               S01:000083DC:  56 00 C1 E5
F00:0420       	STRB      R1,[R1,#0x58+2]    ;T1_go = reset T1					: remet le compteur a la valeur latch ( verrou)
               S01:000083E0:  5A 10 C1 E5
F00:0421       
F00:0422       ; poke our IRQ/FIQ code into &1C-&FC : copie des routines IRQ/FIRQ dans la mémoire basse en 0x18
F00:0423       	MOV       R0,#0
               S01:000083E4:  00 00 A0 E3
F00:0424       	LDR       R1,[R0,#0x18]      ;load current IRQ vector
               S01:000083E8:  18 10 90 E5
F00:0425       	STR       R1,oldIRQbranch
               S01:000083EC:  80 11 8F E5
F00:0426       
F00:0427       	BIC       R1,R1,#0xFF000000
               S01:000083F0:  FF 14 C1 E3
F00:0428       	MOV       R1,R1,LSL#2
               S01:000083F4:  01 11 A0 E1
F00:0429       	ADD       R1,R1,#0x18+8
               S01:000083F8:  20 10 81 E2
F00:0430       	STR       R1,oldIRQaddress
               S01:000083FC:  74 11 8F E5
F00:0431       
F00:0432       ;copy IRQ/FIQ code to &18 onwards
F00:0433       	ldr			R0,pointeur_fiqbase
               S01:00008400:  B8 01 9F E5
F00:0434       	MOV       R1,#0x18	
               S01:00008404:  18 10 A0 E3
F00:0435       	LDMIA     R0!,{R2-R12}
               S01:00008408:  FC 1F B0 E8
F00:0436       	STMIA     R1!,{R2-R12}      ;11 pokey codey
               S01:0000840C:  FC 1F A1 E8
F00:0437       	LDMIA     R0!,{R2-R12}
               S01:00008410:  FC 1F B0 E8
F00:0438       	STMIA     R1!,{R2-R12}      ;22 pokey codey
               S01:00008414:  FC 1F A1 E8
F00:0439       	LDMIA     R0!,{R2-R12}
               S01:00008418:  FC 1F B0 E8
F00:0440       	STMIA     R1!,{R2-R12}      ;33 pokey codey
               S01:0000841C:  FC 1F A1 E8
F00:0441       	LDMIA     R0!,{R2-R12}
               S01:00008420:  FC 1F B0 E8
F00:0442       	STMIA     R1!,{R2-R12}      ;44 pokey codey
               S01:00008424:  FC 1F A1 E8
F00:0443       	LDMIA     R0!,{R2-R12}
               S01:00008428:  FC 1F B0 E8
F00:0444       	STMIA     R1!,{R2-R12}      ;55 pokey codey
               S01:0000842C:  FC 1F A1 E8
F00:0445       	LDMIA     R0!,{R2-R4}
               S01:00008430:  1C 00 B0 E8
F00:0446       	STMIA     R1!,{R2-R4}       ;58 pokey codey (58 max)
               S01:00008434:  1C 00 A1 E8
F00:0447       
F00:0448       ; init des registres permanents
F00:0449       	MOV			R14,#0x3200000         	; 6 2C set R14 to IOC address
               S01:00008438:  32 E6 A0 E3
F00:0450       	mov			R12,#0x3400000
               S01:0000843C:  0D C5 A0 E3
F00:0451       
F00:0452       
F00:0453       .equ 	FIQ_notHSync_valeur, 0xC0
F00:0454       ; on écrit l'adresse de la routine Vsync dans le code IRQ/FIRQ en bas de mémoire  pour revenir si vsync ou keyboard
F00:0455       	adr		R0,VBL					;FNlong_adr("",0,notHSync)   ;set up VSync code after copying
               S01:00008440:  A8 00 8F E2
F00:0456       	MOV     R1,#FIQ_notHSync_valeur 	;ref. works if assembling on RO3, note 'FIQ_notHSync' is 0-relative!
               S01:00008444:  C0 10 A0 E3
F00:0457       	STR       R0,[R1]
               S01:00008448:  00 00 81 E5
F00:0458       
F00:0459       ; sauvegarde de la première instruction pour vérifier la présence du code , pour ne pas lancer plusieurs fois RM, inu
F00:0460       ;	MOV       R0,#0
F00:0461       ;	LDR       R1,[R0,#0x18]      ;first IRQ instruction from our code
F00:0462       ;	STR       R1,newIRQfirstinst
F00:0463       
F00:0464       ; sortie
F00:0465       ;									mode SVC Supervisor
F00:0466       	TEQP      PC,#0b11				; %00<<26 OR %11;enable IRQs and FIQs, change to user mode
               S01:0000844C:  03 F0 3F E3
F00:0467       	MOV       R0,R0
               S01:00008450:  00 00 A0 E1
F00:0468       	
F00:0469       	ldr		lr,save_lr
               S01:00008454:  7C E0 9F E5
F00:0470       	mov		pc,lr					;exit in USER mode and with IRQs and FIQs on
               S01:00008458:  0E F0 A0 E1
F00:0471       
F00:0472       ;----------------------------------------------------------------------------------------------------------------------
F00:0473       wait_VBL:
F00:0474       	LDRB      R11,vsyncbyte   ;load our byte from FIQ address, if enabled
               S01:0000845C:  18 B1 DF E5
F00:0475       waitloop_vbl:
F00:0476       	LDRB      R12,vsyncbyte
               S01:00008460:  14 C1 DF E5
F00:0477       	TEQ       R12,R11
               S01:00008464:  0B 00 3C E1
F00:0478       	BEQ       waitloop_vbl
               S01:00008468:  FC FF FF 0A
F00:0479       	MOVS      PC,R14
               S01:0000846C:  0E F0 B0 E1
F00:0480       
F00:0481       ;----------------------------------------------------------------------------------------------------------------------
F00:0482       
F00:0483       ;----------------------------------------------------------------------------------------------------------------------
F00:0484       scankeyboard:
F00:0485       ; https://www.riscosopen.org/wiki/documentation/show/Low-Level%20Internal%20Key%20Numbers
F00:0486       ; retour : R0 = touche sur 2 octets
F00:0487       	;mov		R12,#0
F00:0488       	;mov		R0,#0
F00:0489       
F00:0490       	LDRB      R12,keybyte2
               S01:00008470:  66 C0 DF E5
F00:0491       	ands			R12,R12,#0b1111
               S01:00008474:  0F C0 1C E2
F00:0492       	beq		  sortie_keycheck
               S01:00008478:  02 00 00 0A
F00:0493       	LDRB      R0,keybyte1
               S01:0000847C:  59 00 DF E5
F00:0494       	ands			R0,R0,#0b1111
               S01:00008480:  0F 00 10 E2
F00:0495       	ORR       R0,R12,R0,LSL#4
               S01:00008484:  00 02 8C E1
F00:0496       
F00:0497       sortie_keycheck:
F00:0498       	mov		pc,lr				; retour 
               S01:00008488:  0E F0 A0 E1
F00:0499       
F00:0500       ;----------------------------------------------------------------------------------------------------------------------
F00:0501       clearkeybuffer:		   ;10 - temp SWI, probably not needed in future once full handler done
F00:0502       	MOV       R12,#0
               S01:0000848C:  00 C0 A0 E3
F00:0503       	STRB      R12,keybyte1
               S01:00008490:  45 C0 CF E5
F00:0504       	STRB      R12,keybyte2
               S01:00008494:  42 C0 CF E5
F00:0505       	MOV       PC,R14      ;flags not preserved
               S01:00008498:  0E F0 A0 E1
F00:0506       
F00:0507       
F00:0508       ;----------------------------------------------------------------------------------------------------------------------
F00:0509       ; routine de verif du clavier executée pendant l'interruption.  lors de la lecture de 0x04, le bit d'interruption est r
F00:0510       check_keyboard:
F00:0511       	;CMP       R13,#256            ;retrace? - this is a backup to disable STx SRx irqs, n/r
F00:0512       	;MOVNE     R8,#%00000000       ;           n/r once everything is working
F00:0513       	;STRNEB    R8,[R14,#&28+2]     ;set IRQB mask to %11000000 = STx or SRx
F00:0514       	;BNE       exitVScode          ;back to IRQ mode and exit
F00:0515       
F00:0516       ; dans la vbl, registres sauvés en debut de VBL
F00:0517       	;ADR       R8,kbd_stack
F00:0518       	;STMIA     R8,{R4-R7}          ;some regs to play with
F00:0519       
F00:0520       ; R14 = IOC 
F00:0521       	MOV       R9,#0x3200000       ; R14 to IOC address
               S01:0000849C:  32 96 A0 E3
F00:0522       	LDRB      R8,[R9,#0x24+0]     ;load irq_B triggers								:IRQ B Status, bit 7 = buffer clavier vide
               S01:000084A0:  24 80 D9 E5
F00:0523       	TST       R8,#0b10000000       ;bit 7 = SRx, cleared by a read from 04
               S01:000084A4:  80 00 18 E3
F00:0524       
F00:0525       	; LDMEQIA     R8,{R4-R7}          ;restore regs
F00:0526       	BEQ         exitVScode          ;back to IRQ mode and exit
               S01:000084A8:  1F 00 00 0A
F00:0527       ;BNE       kbd_received
F00:0528       ;:
F00:0529       ;.kbd_trans
F00:0530       ;TST       R4,#%01000000       ;bit 6 = STx, cleared by a write to 04
F00:0531       ;LDRNEB    R5,nextkeybyte
F00:0532       ;STRNEB    R5,[R14,#&04+2]     ;clear STx
F00:0533       ;MOVNE     R5,#%10000000       ;set mask to wait for ok-to-read
F00:0534       ;STRNEB    R5,[R14,#&28+2]     ;set IRQB mask to %10000000 = SRx
F00:0535       ;:
F00:0536       ;LDMIA     R8,{R4-R7}          ;restore regs
F00:0537       ;B         exitVScode          ;back to IRQ mode and exit
F00:0538       ;
F00:0539       ;
F00:0540       kbd_received:
F00:0541       
F00:0542       ; process key byte, and put ack value in nextkeybyte
F00:0543       
F00:0544       	LDRB      R8,keycounter
               S01:000084AC:  28 80 DF E5
F00:0545       	RSBS      R8,R8,#1            ;if =1 (NE), then this is the first byte, else (EQ)=second byte
               S01:000084B0:  01 80 78 E2
F00:0546       	STRB      R8,keycounter
               S01:000084B4:  20 80 CF E5
F00:0547       
F00:0548       	LDRB      R10,[R9,#0x04+0]     ;load byte, clear SRx							: lors de la lecture de 0x04, le bit d'interruption est remi
               S01:000084B8:  04 A0 D9 E5
F00:0549       	STRNEB    R10,keybyte1															; si pas R10 vide on stock l'octet clavier 1
               S01:000084BC:  19 A0 CF 15
F00:0550       	STRNEB    R9,keybyte2			;clear byte 2!!! (was key-bug until v0.20)
               S01:000084C0:  16 90 CF 15
F00:0551       	
F00:0552       	MOVNE     R8,#0b00111111       ;if first byte, reply with bACK					: pdf TRM A4 : BACK 0011 1111 ACK for first keyboard
               S01:000084C4:  3F 80 A0 13
F00:0553       	STREQB    R10,keybyte2
               S01:000084C8:  0E A0 CF 05
F00:0554       	
F00:0555       	MOVEQ     R8,#0b00110001       ;if second byte, reply with sACK					: pdf TRM A4 : SACK 0011 0001 Last data byte ACK.
               S01:000084CC:  31 80 A0 03
F00:0556       	STRB      R8,[R9,#0x04+2] 		;transmit response = sACK
               S01:000084D0:  06 80 C9 E5
F00:0557       	;STRB      R6,nextkeybyte
F00:0558       
F00:0559       	;MOV       R5,#%01000000       ;set mask to wait for ok-to-transmit
F00:0560       	;STRB      R5,[R14,#&28+2]     ;set IRQB mask to %01000000 = STx
F00:0561       	
F00:0562       	;LDMIA     R8,{R4-R7}          ;restore regs
F00:0563       	B         exitVScode          ;back to IRQ mode and exit
               S01:000084D4:  14 00 00 EA
F00:0564       	;B         kbd_trans
F00:0565       
F00:0566       
F00:0567       ; bACK=%00111111
F00:0568       ; sACK=%00110001
F00:0569       save_lr:		.long		0
               S01:000084D8:  00 00 00 00
F00:0570       
F00:0571       
F00:0572       keycounter:  .byte 0 ;1 or 0
               S01:000084DC:  00
F00:0573       keybyte1:    .byte 0
               S01:000084DD:  00
F00:0574       keybyte2:    .byte 0
               S01:000084DE:  00
F00:0575       nextkeybyte: .byte 0
               S01:000084DF:  00
F00:0576       
F00:0577       kbd_stack:
F00:0578       .long      0 ;R4
               S01:000084E0:  00 00 00 00
F00:0579       .long      0 ;R5
               S01:000084E4:  00 00 00 00
F00:0580       .long      0 ;R6
               S01:000084E8:  00 00 00 00
F00:0581       .long      0 ;R7
               S01:000084EC:  00 00 00 00
F00:0582       
F00:0583       
F00:0584       ;currently have rem'd the disable STx SRx irqs in hsync code and checkkeyboard code
F00:0585       
F00:0586       ;next try only enabling receive, assume transmit is ok...
F00:0587       
F00:0588       ;something wrong - &FFFF (HRST) seems to be only byte received
F00:0589       ;v0.14 worked when trying only enabling receive, assume transmit is ok...
F00:0590       
F00:0591       ; on arrive avec:
F00:0592       ; sauvegarde de R14 dans saveR14_firq en 0xE0
F00:0593       ; sauvegarde de R4-R7 dans FIQ_tempstack en 0xD0
F00:0594       ;  R14 = pointeur sur saveR14_firq
F00:0595       ;  R8 = load irq_A triggers ( anciennement R8) R4 
F00:0596       ;  R5 = 0x3200000 ( anciennement R14)  - IOC -
F00:0597       ;  R6 = ...
F00:0598       ;  R7 = ...
F00:0599       
F00:0600       ;----------------------------------------------------------------------------------------------------------------------
F00:0601       VBL:
F00:0602       	TST       R8,#0b00001000       ;retest R5 is it bit 3 = Vsync? (bit 6 = T1 trigger/HSync)				: R8 = 0x14 = IRQ Request 
               S01:000084F0:  08 00 18 E3
F00:0603       	STRNEB    R14,[R14,#0x58+2]    ;if VSync, reset T1 (latch should already have the vsyncvalue...)		: si vsync, alors on 
               S01:000084F4:  5A E0 CE 15
F00:0604       ;
F00:0605       ; that's the high-priority stuff done, now we can check keyboard too...
F00:0606       ;
F00:0607       	BEQ       check_keyboard       ;check IRQ_B for SRx/STx interrupts									: R8=0 / si 0, c'est qu'on a ni bit3=vsync, 
               S01:000084F8:  E7 FF FF 0A
F00:0608       
F00:0609       	STRB      R8,[R14,#0x14+2]     ; ...and clear all IRQ_A interrupt triggers								: 1 = clear, donc ré-écrire la vale
               S01:000084FC:  16 80 CE E5
F00:0610       
F00:0611       ; remaskage IRQ A : Timer 1 + Vsync
F00:0612       	MOV       R8,#0b00001000		; EDZ : Vsync only
               S01:00008500:  08 80 A0 E3
F00:0613       
F00:0614       	STRB      R8,[R14,#0x18+2]     ;set IRQA mask to %01000000 = T1 only									: mask IRQ A : bit 6 = Timer 1, plus de Vs
               S01:00008504:  1A 80 CE E5
F00:0615       
F00:0616       ; remaskage IRQ B : clavier/keyboard
F00:0617       	MOV       R8,#0b10000000       ;R8,#%11000000
               S01:00008508:  80 80 A0 E3
F00:0618       	STRB      R8,[R14,#0x28+2]     ;set IRQB mask to %11000000 = STx or SRx									: mask IRQ B pour clavier
               S01:0000850C:  2A 80 CE E5
F00:0619       
F00:0620       
F00:0621       ; vsyncbyte = 3 - vsyncbyte
F00:0622       ; sert de flag de vsync, si modifié => vsync
F00:0623       	LDRB      R8,vsyncbyte
               S01:00008510:  64 80 DF E5
F00:0624       	RSB       R8,R8,#3
               S01:00008514:  03 80 68 E2
F00:0625       	STRB      R8,vsyncbyte
               S01:00008518:  5C 80 CF E5
F00:0626       
F00:0627       	adr		R8,pile_regs
               S01:0000851C:  5C 80 8F E2
F00:0628       	stmia	R8,{R0-R7}
               S01:00008520:  FF 00 88 E8
F00:0629       
F00:0630       
F00:0631       	.ifeq	1
F00:0632       	ldr		R9,adresse_dma2_memc
F00:0633       	add		R8,R9,#nb_octets_par_vbl-2
F00:0634       
F00:0635       
F00:0636       	mov		r9,r9,lsr #4
F00:0637       	mov		r9,r9,lsl #2
F00:0638       	
F00:0639       	mov		r8,r8,lsr #4
F00:0640       	mov		r8,r8,lsl #2
F00:0641       
F00:0642       	MOV		R10,#0x36A0000     ; SendN
F00:0643       	add		R8,R8,R10
F00:0644       
F00:0645       
F00:0646       	MOV		R10,#0x3680000     ; Sstart
F00:0647       	add		R9,R9,R10
F00:0648       
F00:0649       	str		R8,[R8]	
F00:0650       	str		R9,[R9]
F00:0651       
F00:0652       
F00:0653       	ldr		R8,adresse_dma2_memc
F00:0654       	ldr		R9,adresse_dma1_memc
F00:0655       	str		R8,adresse_dma1_memc
F00:0656       	str		R9,adresse_dma2_memc
F00:0657       
F00:0658       	ldr		R8,adresse_dma1_logical
F00:0659       	ldr		R9,adresse_dma2_logical
F00:0660       	str		R8,adresse_dma2_logical
F00:0661       	str		R9,adresse_dma1_logical
F00:0662       
F00:0663       
F00:0664       
F00:0665       
F00:0666       
F00:0667       	mov   r9,#0x3400000               
F00:0668       	mov   r8,#777
F00:0669       ; border	
F00:0670       	orr   r8,r8,#0x40000000            
F00:0671       	str   r8,[r9]  
F00:0672       
F00:0673       
F00:0674       
F00:0675       ; --------------------
F00:0676       	ldr		R2,adresse_dma1_logical
F00:0677       	ldr		R5,fin_sample
F00:0678       	ldr		R1,pointeur_lecture_sample
F00:0679       	mov		R0,#nb_octets_par_vbl
F00:0680       	mov		R4,#0b11111110
F00:0681       	adr		R6,lin2logtab
F00:0682       	mov		R7,#127
F00:0683       	mov		R3,#0
F00:0684       bouclecopie2:
F00:0685       
F00:0686       
F00:0687       	ldrb		R3,[r1],#4
F00:0688       	ldrb		R3,[R6,R3]
F00:0689       	;and			R3,R3,R4
F00:0690       	;subs		R3,R3,#1
F00:0691       	;movmi		R3,#0
F00:0692       
F00:0693       	strb		R3,[R2],#1
F00:0694       	
F00:0695       	cmp		R1,R5
F00:0696       	;blt		.pas_fin_de_sample2
F00:0697       	ldrlt		R1,debut_sample
F00:0698       
F00:0699       .pas_fin_de_sample2:
F00:0700       	subs	R0,R0,#1
F00:0701       	bgt		bouclecopie2
F00:0702       	str		R1,pointeur_lecture_sample
F00:0703       
F00:0704       	.endif
F00:0705       
F00:0706       	adr		R8,pile_regs
               S01:00008524:  54 80 8F E2
F00:0707       	ldmia	R8,{R0-R7}
               S01:00008528:  FF 00 98 E8
F00:0708       
F00:0709       exitVScode:
F00:0710       	mov   r9,#0x3400000                
               S01:0000852C:  0D 95 A0 E3
F00:0711       	mov   r8,#000
               S01:00008530:  00 80 A0 E3
F00:0712       ; border	
F00:0713       	orr   r8,r8,#0x40000000            
               S01:00008534:  01 81 88 E3
F00:0714       	str   r8,[r9]  
               S01:00008538:  00 80 89 E5
F00:0715       
F00:0716       
F00:0717       
F00:0718       ;	mode IRQ mode, 
F00:0719       	TEQP      PC,#0x0C000002			; %000011<<26 OR %10 ;36 A4 back to IRQ mode				: xor sur bits 27&26 = autorise IRQ et FIRQ.
               S01:0000853C:  83 F3 3F E3
F00:0720       	MOV       R0,R0                  ;37 A8 sync IRQ registers
               S01:00008540:  00 00 A0 E1
F00:0721       	SUBS      PC,R14,#4              ;38 AC return to foreground
               S01:00008544:  04 F0 5E E2
F00:0722       ;----------------------------------------------------------------------------------------------------------------------
F00:0723       
F00:0724       
F00:0725       ; ---------------------
F00:0726       ; variables RM
F00:0727       os_version:		.long      0         ;1 byte &A0 for Arthur 0.3/1.2, &A1 for RO2, &A3 for RO3.0, &A4 for RO3.1
               S01:00008548:  00 00 00 00
F00:0728       fiqoriginal:	
F00:0729       .long      0         ;R8
               S01:0000854C:  00 00 00 00
F00:0730       .long      0         ;R9
               S01:00008550:  00 00 00 00
F00:0731       .long      0         ;R10
               S01:00008554:  00 00 00 00
F00:0732       .long      0         ;R11
               S01:00008558:  00 00 00 00
F00:0733       .long      0         ;R12
               S01:0000855C:  00 00 00 00
F00:0734       .long      0         ;R13
               S01:00008560:  00 00 00 00
F00:0735       .long      0         ;R14
               S01:00008564:  00 00 00 00
F00:0736       
F00:0737       oldIRQa:	.long	0				; ancien vecteur IRQ A du système
               S01:00008568:  00 00 00 00
F00:0738       oldIRQb:	.long	0				; ancien vecteur IRQ B du système
               S01:0000856C:  00 00 00 00
F00:0739       newIRQfirstinst:	.long	0	
               S01:00008570:  00 00 00 00
F00:0740       oldIRQbranch:		.long 	0
               S01:00008574:  00 00 00 00
F00:0741       oldIRQaddress:		.long	0
               S01:00008578:  00 00 00 00
F00:0742       
F00:0743       vsyncbyte:		.long 	0
               S01:0000857C:  00 00 00 00
F00:0744       
F00:0745       pile_regs:
F00:0746       		.rept		16
F00:0748       
F02:0001       		.long		0
               S01:00008580:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:00008584:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:00008588:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:0000858C:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:00008590:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:00008594:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:00008598:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:0000859C:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085A0:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085A4:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085A8:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085AC:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085B0:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085B4:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085B8:  00 00 00 00
F02:0002       		
F02:0001       		.long		0
               S01:000085BC:  00 00 00 00
F02:0002       		
F00:0749       
F00:0750       
F00:0751       
F00:0752       pointeur_fiqbase:		.long	fiqbase
               S01:000085C0:  C4 85 00 00
F00:0753       fiqbase:              ;copy to &18 onwards, 57 instructions max
F00:0754                             ;this pointer must be relative to module
F00:0755       
F00:0756       		.incbin		"build\fiqrmi2.bin"
               S01:000085C4:  43 F3 3F E3 00 00 A0 E1 14 80 DE E5 40 00 18 E3
               S01:000085D4:  90 F0 9F 05 16 80 CE E5 83 F3 3F E3 00 00 A0 E1
F00:0757       
F00:0758       
F00:0759       fiqend:
F00:0760       
F00:0761       
F00:0762       
F00:0763       ;-------------------- DATA ----------------------------------		
F00:0764       
F00:0765       
F00:0766       memc_control_register_original:			.long	0
               S01:000086AC:  00 00 00 00
F00:0767       taille_actuelle_memoire_ecran:			.long		0
               S01:000086B0:  00 00 00 00
F00:0768       
F00:0769       adresse_dma1_logical:				.long		0
               S01:000086B4:  00 00 00 00
F00:0770       ;adresse_dma1_logical_courant:		.long		0
F00:0771       adresse_dma1_logical_fin:			.long		0
               S01:000086B8:  00 00 00 00
F00:0772       adresse_dma1_memc:					.long		0
               S01:000086BC:  00 00 00 00
F00:0773       ;adresse_dma1_memc_courant:			.long		0
F00:0774       
F00:0775       
F00:0776       adresse_dma2_logical:				.long		0
               S01:000086C0:  00 00 00 00
F00:0777       ;adresse_dma2_logical_courant:		.long		0
F00:0778       adresse_dma2_logical_fin:			.long		0
               S01:000086C4:  00 00 00 00
F00:0779       adresse_dma2_memc:					.long		0
               S01:000086C8:  00 00 00 00
F00:0780       adresse_dma2_memc_courant:			.long		0
               S01:000086CC:  00 00 00 00
F00:0781       
F00:0782       pagefindblk:
F00:0783       		.long      0 ;0
               S01:000086D0:  00 00 00 00
F00:0784       		.long      0 ;4
               S01:000086D4:  00 00 00 00
F00:0785       		.long      0 ;8
               S01:000086D8:  00 00 00 00
F00:0786       		.long      0 ;12
               S01:000086DC:  00 00 00 00
F00:0787       
F00:0788       page_block:
F00:0789       	.long		0		; Physical page number 
               S01:000086E0:  00 00 00 00
F00:0790       	.long		0		; Logical address 
               S01:000086E4:  00 00 00 00
F00:0791       	.long		0		; Physical address 
               S01:000086E8:  00 00 00 00
F00:0792       
F00:0793       pagesize:		.long	0
               S01:000086EC:  00 00 00 00
F00:0794       numpages:		.long	0
               S01:000086F0:  00 00 00 00
F00:0795       
F00:0796       backup_params_sons:	
F00:0797       	.long		0
               S01:000086F4:  00 00 00 00
F00:0798       	.long		0
               S01:000086F8:  00 00 00 00
F00:0799       	.long		0
               S01:000086FC:  00 00 00 00
F00:0800       	.long		0
               S01:00008700:  00 00 00 00
F00:0801       	.long		0
               S01:00008704:  00 00 00 00
F00:0802       	.long		0
               S01:00008708:  00 00 00 00
F00:0803       
F00:0804       
F00:0805       pointeur_sample:		.long		sample
               S01:0000870C:  14 88 00 00
F00:0806       pointeur_fin_sample:	.long		fin_sample
               S01:00008710:  91 60 04 00
F00:0807       	
F00:0808       lin2logtab:		.skip		256
F00:0809       
F00:0810       
F00:0811       sample:
F00:0812       		.incbin	"music8000s.pcm"
               S01:00008814:  00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
               S01:00008824:  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
F00:0813       fin_sample:
F00:0814       	


Sections:
S01  seg8000


Sources:
F00  playsample.asm
F01  swis.h.asm
F02  REPEAT:playsample.asm:line 748


Symbols:
fin_sample EXPR(286865=0x46091) ABS 
pointeur_fin_sample EXPR(34576=0x8710) UNUSED ABS 
sample EXPR(34836=0x8814) ABS 
page_block EXPR(34528=0x86e0) UNUSED ABS 
fiqend EXPR(34476=0x86ac) UNUSED ABS 
fiqbase EXPR(34244=0x85c4) ABS 
newIRQfirstinst EXPR(34160=0x8570) UNUSED ABS 
os_version EXPR(34120=0x8548) UNUSED ABS 
pile_regs EXPR(34176=0x8580) ABS 
kbd_stack EXPR(34016=0x84e0) UNUSED ABS 
nextkeybyte EXPR(34015=0x84df) UNUSED ABS 
keycounter EXPR(34012=0x84dc) ABS 
kbd_received EXPR(33964=0x84ac) UNUSED ABS 
exitVScode EXPR(34092=0x852c) ABS 
check_keyboard EXPR(33948=0x849c) ABS 
clearkeybuffer EXPR(33932=0x848c) UNUSED ABS 
keybyte1 EXPR(34013=0x84dd) ABS 
sortie_keycheck EXPR(33928=0x8488) ABS 
keybyte2 EXPR(34014=0x84de) ABS 
waitloop_vbl EXPR(33888=0x8460) ABS 
vsyncbyte EXPR(34172=0x857c) ABS 
VBL EXPR(34032=0x84f0) ABS 
FIQ_notHSync_valeur EXPR(192=0xc0) 
pointeur_fiqbase EXPR(34240=0x85c0) ABS 
oldIRQaddress EXPR(34168=0x8578) ABS 
fiqoriginal EXPR(34124=0x854c) ABS 
oldIRQb EXPR(34156=0x856c) ABS 
oldIRQa EXPR(34152=0x8568) ABS 
oldIRQbranch EXPR(34164=0x8574) ABS 
save_lr EXPR(34008=0x84d8) ABS 
setlinlogtab EXPR(33576=0x8328) ABS 
create_table_lin2log EXPR(33568=0x8320) UNUSED ABS 
boucle_table_lin2log_edz EXPR(33540=0x8304) ABS 
boucle_copie_sample_en_entier EXPR(33416=0x8288) ABS 
boucle_convert_sample_mu_law EXPR(33364=0x8254) ABS 
lin2logtab EXPR(34580=0x8714) ABS 
pointeur_sample EXPR(34572=0x870c) ABS 
remove_VBL EXPR(33600=0x8340) ABS 
exit EXPR(33280=0x8200) ABS 
test_touche_space EXPR(33272=0x81f8) UNUSED ABS 
scankeyboard EXPR(33904=0x8470) ABS 
wait_VBL EXPR(33884=0x845c) ABS 
boucle EXPR(33244=0x81dc) ABS 
set_dma_dma1 EXPR(33464=0x82b8) ABS 
install_vsync EXPR(33676=0x838c) ABS 
backup_params_sons EXPR(34548=0x86f4) ABS 
copie_sample_dans_buffer_dma_en_entier EXPR(33396=0x8274) ABS 
continue EXPR(33084=0x813c) ABS 
boucle_cls_buffer_dma EXPR(33064=0x8128) ABS 
valeurson EXPR(33080=0x8138) ABS 
adresse_dma1_memc EXPR(34492=0x86bc) ABS 
adresse_dma2_memc_courant EXPR(34508=0x86cc) ABS 
adresse_dma2_memc EXPR(34504=0x86c8) ABS 
pagefindblk EXPR(34512=0x86d0) ABS 
numpages EXPR(34544=0x86f0) ABS 
pagesize EXPR(34540=0x86ec) ABS 
adresse_dma2_logical_fin EXPR(34500=0x86c4) ABS 
adresse_dma2_logical EXPR(34496=0x86c0) ABS 
adresse_dma1_logical_fin EXPR(34488=0x86b8) ABS 
adresse_dma1_logical EXPR(34484=0x86b4) ABS 
taille_actuelle_memoire_ecran EXPR(34480=0x86b0) ABS 
conversion_du_sample_en_mu_law EXPR(33344=0x8240) ABS 
create_table_lin2log_edz EXPR(33524=0x82f4) ABS 
memc_control_register_original EXPR(34476=0x86ac) ABS 
ms_freq_Archi EXPR(32=0x20) 
longueur_du_sample EXPR(75851=0x1284b) 
taille_dma EXPR(83200=0x14500) 
XSound_Stereo EXPR(393538=0x60142) UNUSED 
Sound_Stereo EXPR(262466=0x40142) UNUSED 
XSound_Enable EXPR(393537=0x60141) 
XSound_Configure EXPR(393536=0x60140) 
XSound_Volume EXPR(393600=0x60180) 
XSound_SoundLog EXPR(393601=0x60181) 
OS_FindMemMapEntries EXPR(96=0x60) 
OS_ReadMemMapInfo EXPR(81=0x51) 
XOS_ServiceCall EXPR(131120=0x20030) 
BKP EXPR(281477=0x44b85) UNUSED 
RasterMan_ReadScanAddr EXPR(294539=0x47e8b) UNUSED 
RasterMan_ClearKeyBuffer EXPR(294538=0x47e8a) UNUSED 
RasterMan_ScanKeyboard EXPR(294537=0x47e89) UNUSED 
RasterMan_QTMParamAddr EXPR(294536=0x47e88) UNUSED 
RasterMan_SetMEMCRegister EXPR(294535=0x47e87) UNUSED 
RasterMan_SetVIDCRegister EXPR(294534=0x47e86) UNUSED 
RasterMan_ReadScanline EXPR(294533=0x47e85) UNUSED 
RasterMan_Wait EXPR(294530=0x47e82) UNUSED 
RasterMan_Release EXPR(294529=0x47e81) UNUSED 
RasterMan_Install EXPR(294528=0x47e80) UNUSED 
RasterMan_SetTables EXPR(294531=0x47e83) UNUSED 
RasterMan_Version EXPR(294532=0x47e84) UNUSED 
QTM_SetSampleSpeed EXPR(294473=0x47e49) UNUSED 
QTM_Stop EXPR(294466=0x47e42) UNUSED 
QTM_Start EXPR(294465=0x47e41) UNUSED 
QTM_Load EXPR(294464=0x47e40) UNUSED 
OS_ConvertHex8 EXPR(212=0xd4) UNUSED 
OS_ConvertHex4 EXPR(210=0xd2) UNUSED 
OS_ConvertHex2 EXPR(209=0xd1) UNUSED 
Event_VSync EXPR(4=0x4) UNUSED 
EventV EXPR(16=0x10) UNUSED 
ErrorV EXPR(1=0x1) UNUSED 
OS_AddToVector EXPR(71=0x47) UNUSED 
OS_Release EXPR(32=0x20) UNUSED 
OS_Claim EXPR(31=0x1f) UNUSED 
VD_ScreenStart EXPR(148=0x94) UNUSED 
DynArea_Screen EXPR(2=0x2) 
IKey_Space EXPR(157=0x9d) UNUSED 
IKey_RightClick EXPR(244=0xf4) UNUSED 
IKey_LeftClick EXPR(246=0xf6) UNUSED 
OSWord_WritePalette EXPR(12=0xc) UNUSED 
OSByte_ReadKey EXPR(129=0x81) UNUSED 
OSByte_WriteDisplayBank EXPR(113=0x71) UNUSED 
OSByte_WriteVDUBank EXPR(112=0x70) UNUSED 
OSByte_Vsync EXPR(19=0x13) UNUSED 
OSByte_EventDisable EXPR(13=0xd) UNUSED 
OSByte_EventEnable EXPR(14=0xe) UNUSED 
OS_Module EXPR(30=0x1e) UNUSED 
OS_supervisor EXPR(22=0x16) UNUSED 
OS_EnterOS EXPR(22=0x16) 
OS_ConvertCardinal4 EXPR(216=0xd8) UNUSED 
OS_ReadDynamicArea EXPR(92=0x5c) 
OS_ReadMonotonicTime EXPR(66=0x42) UNUSED 
OS_ReadVduVariables EXPR(49=0x31) UNUSED 
OS_GenerateError EXPR(43=0x2b) UNUSED 
OS_ChangeDynamicArea EXPR(42=0x2a) 
OS_BreakPt EXPR(23=0x17) UNUSED 
OS_Exit EXPR(17=0x11) 
OS_File EXPR(8=0x8) UNUSED 
OS_Word EXPR(7=0x7) UNUSED 
XOS_Byte EXPR(131078=0x20006) UNUSED 
OS_Byte EXPR(6=0x6) 
OS_NewLine EXPR(3=0x3) UNUSED 
OS_WriteO EXPR(2=0x2) UNUSED 
OS_WriteC EXPR(0=0x0) 
__VASM EXPR(0=0x0) INTERNAL 
__MSDOSFS EXPR(0=0x0) INTERNAL 

There have been no errors.
